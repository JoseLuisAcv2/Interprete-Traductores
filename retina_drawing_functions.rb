#
# 	Traductores e Interpretadores CI-3725
# 	
# 	Proyecto Fase 4 - Interpreter
#
#  	Retina Drawing Library
#
# 	Autores:
# 				- Jose Acevedo		13-10006
#               - Edwar Yepez       12-10855
#

# Image generated by Retina program
class Image

	def initialize(height=1001, width=1001, cursor_x=0, cursor_y=0, degree=90, opened_eye=true)
		@height = height.round
		@width = width.round
		@image = Array.new(@height) { Array.new(@width) { 0 } }
		@cursor_x = cursor_x.round
		@cursor_y = cursor_y.round
		@degree = degree
		@opened_eye = opened_eye

		# Mark initial position
		@image[convert_y_to_row(@cursor_y)][convert_x_to_column(@cursor_x)] = 1
	end

	# Check if function is predefined
	def is_retina_function(funcIdent)
		# Return true if match found
		return ["home","openeye","closeeye","forward","backward","rotater","rotatel","setposition","arc"].include? funcIdent
	end

	def call_retina_function(funcIdent, arg1 = nil, arg2 = nil)
		# If match found then call function
		case funcIdent
		when "home"
			home()
		
		when "openeye"
			openeye()
		
		when "closeeye"
			closeeye()
		
		when "forward"
			steps = arg1
			forward(steps)
		
		when "backward"
			steps = arg1
			backward(steps)
		
		when "rotater"
			degree = arg1
			rotater(degree)
		
		when "rotatel"
			degree = arg1
			rotatel(degree)
		
		when "setposition"
			x = arg1
			y = arg2
			setposition(x,y)
		
		when "arc"
			degree = arg1
			radius = arg2
			arc(degree,radius)
		
		end
	end

	# Reset cursor coordinates to center of image	
	def home()
		@cursor_y = 0
		@cursor_x = 0
	end
	
	# Enable cursor to mark movement
	def openeye()
		@opened_eye = true
	end
	
	# Disable cursor to mark movement
	def closeeye()
		@opened_eye = false
	end

	# Go forward number of steps specified
	def forward(steps)
		# Calculate ending coordinates
		rad = @degree * Math::PI / 180

		new_x = (@cursor_x + steps*Math.cos(rad)).round
		new_y = (@cursor_y + steps*Math.sin(rad)).round
	
		if(@opened_eye) then
			draw_points(@cursor_x, @cursor_y, new_x, new_y)
		end

		# Update coordinates
		@cursor_x = new_x
		@cursor_y = new_y
	end
	
	# Go backwards number of steps specified
	def backward(steps)
		# Calculate ending coordinates
		rad = @degree * Math::PI / 180
		new_x = (@cursor_x - steps*Math.cos(rad)).round
		new_y = (@cursor_y - steps*Math.sin(rad)).round

		if(@opened_eye) then
			draw_points(@cursor_x, @cursor_y, new_x, new_y)
		end

		# Update coordinates
		@cursor_x = new_x
		@cursor_y = new_y
	end
	
	# Rotate cursor clockwise
	def rotater(rotationDegree)
		@degree = (@degree - rotationDegree) % 360;
	end
	
	# Rotate cursor counterclockwise
	def rotatel(rotationDegree)
		@degree = (@degree + rotationDegree) % 360;
	end
	
	# Set cursor coordinates
	def setposition(x,y)
		@cursor_x = x.round
		@cursor_y = y.round
	end
	
	def arc(degree,radius)
	end

	# Store image in .pbm file
	def store()
		# Get filename of input program
		filename = ARGV[0]
		# Remove extension
		filename = File.basename(filename,".rtn")
		# Add extension
		filename << ".pbm"

		# Create new file
		newFile = File.open(filename, "w")
	
		# Add magid number and dimensions of matrix
		newFile.puts("P1")
		newFile.print(@width)
		newFile.print(' ')
		newFile.puts(@height)

		# Store matrix in file
		@image.each do |row|
			row.each do |pixel|
				newFile.print pixel, ' '
			end
			newFile.puts
		end

		# Close stream
		newFile.close
	end

	# Draw points on line from (x0,y0) to (x1,y1)
	def draw_points(x0, y0, x1, y1)
		# Get array of points on line
		points = get_line(x0,x1,y0,y1)
		
		points.each do |point|
			x = point[:x]	
			y = point[:y]	
		
			# Convert cartesian coordinates
			row = convert_y_to_row(y)
			column = convert_x_to_column(x)

			# Turn pixel on
			if(in_image(row,column)) then
				@image[row][column] = 1
			end
		end

	end

	# Get points on line from (x0,y0) to (x1,y1)
	def get_line(x0,x1,y0,y1)
  		points = []
		steep = ((y1-y0).abs) > ((x1-x0).abs)
		if steep then
			x0,y0 = y0,x0
			x1,y1 = y1,x1
		end
		if x0 > x1
			x0,x1 = x1,x0
			y0,y1 = y1,y0
		end
		deltax = x1-x0
		deltay = (y1-y0).abs
		error = (deltax / 2).to_i
		y = y0
		ystep = nil
		if y0 < y1 then
			ystep = 1
		else
			ystep = -1
		end
		for x in x0..x1
			if steep then
				points << {:x => y, :y => x}
			else
				points << {:x => x, :y => y}
			end
			error -= deltay
			if error < 0 then
				y += ystep
				error += deltax
			end
		end
		return points
	end

	# Check point lies inside matrix
	def in_image(row, column)
		return (0<=row and row<@height and 0<=column and column<@width)
	end

	# Auxiliary function to convert x coordinate from
	# cartesian system to matrix column
	def convert_x_to_column(x)
		return (((@width-1)/2) + x).round
	end

	# Auxiliary function to convert y coordinate from
	# cartesian system to matrix row
	def convert_y_to_row(y)
		return (((@width-1)/2) - y).round
	end
end