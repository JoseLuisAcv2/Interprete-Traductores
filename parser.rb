#
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.4.14
# from Racc grammer file "".
#

require 'racc/parser.rb'


require_relative "retina_lexer"
require_relative "retina_ast"

class SyntacticError < RuntimeError

    def initialize(tok)
        @token = tok
    end

    def to_s
        "Syntactic error on line #{@token.line}, column #{@token.column}: #{@token.value}"   
    end
end

class Parser < Racc::Parser

module_eval(<<'...end retina_parser.y/module_eval...', 'retina_parser.y', 227)

def on_error(id, token, stack)
    raise SyntacticError::new(token)
end

def next_token
    if @lexer.has_next_token then
        token = @lexer.next_token;
        return [token.symbol,token]
    else
        return [false,false];
    end
end

def parse(lexer)
    @yydebug = true
    @lexer = lexer
    @tokens = []
    ast = do_parse
    return ast
end
...end retina_parser.y/module_eval...
##### State transition tables begin ###

racc_action_table = [
     3,     4,     5,     3,     7 ]

racc_action_check = [
     0,     1,     2,     3,     4 ]

racc_action_pointer = [
   -45,     1,   -42,   -42,     4,   nil,   nil,   nil ]

racc_action_default = [
    -4,    -6,    -2,    -4,    -6,    -1,    -3,     8 ]

racc_goto_table = [
     2,     1,   nil,     6 ]

racc_goto_check = [
     2,     1,   nil,     2 ]

racc_goto_pointer = [
   nil,     1,     0,   nil ]

racc_goto_default = [
   nil,   nil,   nil,   nil ]

racc_reduce_table = [
  0, 0, :racc_error,
  2, 48, :_reduce_none,
  1, 48, :_reduce_none,
  2, 49, :_reduce_none,
  0, 49, :_reduce_none,
  2, 50, :_reduce_none ]

racc_reduce_n = 6

racc_shift_n = 8

racc_token_table = {
  false => 0,
  :error => 1,
  :APRNTS => 2,
  :BPRNTS => 3,
  :NOT => 4,
  :UMINUS => 5,
  :ARITHMETICOP => 6,
  :PLUS => 7,
  :MINUS => 8,
  :ORDEROP => 9,
  :EQUALITYOP => 10,
  :BOOLEANOP => 11,
  :ASSIGNOP => 12,
  :SEMICOLON => 13,
  :PROGRAM => 14,
  :BEGINBLK => 15,
  :ENDBLK => 16,
  :WITH => 17,
  :DO => 18,
  :REPEAT => 19,
  :TIMES => 20,
  :READ => 21,
  :WRITE => 22,
  :WRITELN => 23,
  :IF => 24,
  :THEN => 25,
  :ELSE => 26,
  :WHILE => 27,
  :FOR => 28,
  :FROM => 29,
  :TO => 30,
  :BY => 31,
  :FUNC => 32,
  :RETURN => 33,
  :RETURNTYPE => 34,
  :TYPE => 35,
  :BOOLEAN => 36,
  :LPARENTH => 37,
  :RPARENTH => 38,
  :SEP => 39,
  :COLON => 40,
  :NUMBER => 41,
  :STRING => 42,
  :IDENTIFIER => 43,
  :PROGRAMBLOCK => 44,
  :DEF => 45,
  "                PROGRAMBLOCK        : PROGRAM INSTR ENDBLK SEP        ;        DEF        : FUNC IDENT LPARENTH PARAMLIST RPARENTH BEGINBLK FUNCINSTR ENDBLK SEP        | FUNC IDENT LPARENTH PARAMLIST RPARENTH RETURNTYPE TYPE BEGINBLK FUNCINSTR ENDBLK SEP        | FUNC IDENT LPARENTH RPARENTH BEGINBLK FUNCINSTR ENDBLK SEP        | FUNC IDENT LPARENTH RPARENTH BEGINBLK RETURNTYPE TYPE FUNCINSTR ENDBLK SEP        ;                IDENT        : IDENTIFIER        ;        PARAMLIST        : PARAM COLON PARAMLIST        | PARAM        ;                FUNCINSTR        : INSTR FUNCINSTR        | FUNCCOND SEP FUNCINSTR        | FUNCITER SEP FUNCINSTR        | FUNCWITHBLOCK SEP FUNCINSTR         | RETURNEXPR SEP FUNCINSTR        |         ;                PARAM        : TYPE IDENT        ;                INSTR        : EXPR SEP INSTR         | ASSIGN SEP INSTR        | COND SEP INSTR        | ITER SEP INSTR        | READBLOCK SEP INSTR        | WRITEBLOCK SEP INSTR        | WITHBLOCK SEP INSTR        |         ;                FUNCCOND        : IF BEXPR THEN FUNCINSTR ENDBLK        | IF BEXPR THEN FUNCINSTR ELSE FUNCINSTR ENDBLK        ;                FUNCITER        : WHILE BEXPR DO FUNCINSTR ENDBLK         | FOR IDENT FROM AEXPR TO AEXPR BY AEXPR DO FUNCINSTR ENDBLK        | FOR IDENT FROM AEXPR TO AEXPR DO FUNCINSTR ENDBLK        | REPEAT AEXPR TIMES FUNCINSTR ENDBLK        ;                FUNCWITHBLOCK        : WITH DECLBLOCK SEP DO FUNCINSTR ENDBLK        ;                RETURNEXPR         : RETURN        | RETURN EXPR        ;                EXPR        : AEXPR        | BEXPR        ;                ASSIGN        : IDENT ASSIGNOP EXPR        ;                COND        : IF BEXPR THEN INSTR ENDBLK        | IF BEXPR THEN INSTR ELSE INSTR ENDBLK        ;                ITER        : WHILE BEXPR DO INSTR ENDBLK         | FOR IDENT FROM AEXPR TO AEXPR BY AEXPR DO INSTR ENDBLK        | FOR IDENT FROM AEXPR TO AEXPR DO INSTR ENDBLK        | REPEAT AEXPR TIMES INSTR ENDBLK        ;                READBLOCK        : READ IDENT        ;                WRITEBLOCK        : WRITE PRINTLIST        | WRITELN PRINTLIST        ;                WITHBLOCK        : WITH DECLBLOCK SEP DO INSTR ENDBLK        ;                BEXPR        : BEXPR BOOLEANOP BEXPR        | LPARENTH BEXPR RPARENTH  = BPRNTS        | NOT BEXPR        | EXPR EQUALITYOP EXPR        | AEXPR ORDEROP AEXPR        | B        | IDENT        | CALLFUNC        ;                AEXPR        : AEXPR ARITHMETICOP AEXPR        | AEXPR MINUS AEXPR        | LPARENTH AEXPR RPARENTH  = APRNTS        | MINUS AEXPR   =UMINUS        | N        | IDENT        | CALLFUNC        ;                DECLBLOCK        : DECL DECLBLOCK        |        ;                PRINTLIST        : STRING COLON PRINTLIST        | EXPR COLON PRINTLIST        | STRING        | EXPR        ;                B        : BOOLEAN        ;                N        : NUMBER        ;                CALLFUNC        : IDENT LPARENTH TERMINALLIST RPARENTH        | IDENT LPARENTH RPARENTH        ;                DECL        : TYPE IDENTLIST SEP        | TYPE ASSIGN SEP        ;                TERMINALLIST        : B COLON TERMINALLIST        | N COLON TERMINALLIST        | IDENT COLON TERMINALLIST        | B        | N        | IDENT        ;                IDENTLIST        : IDENT COLON IDENTLIST        | IDENT        ;                        " => 46 }

racc_nt_base = 47

racc_use_result_var = true

Racc_arg = [
  racc_action_table,
  racc_action_check,
  racc_action_default,
  racc_action_pointer,
  racc_goto_table,
  racc_goto_check,
  racc_goto_default,
  racc_goto_pointer,
  racc_nt_base,
  racc_reduce_table,
  racc_token_table,
  racc_shift_n,
  racc_reduce_n,
  racc_use_result_var ]

Racc_token_to_s_table = [
  "$end",
  "error",
  "APRNTS",
  "BPRNTS",
  "NOT",
  "UMINUS",
  "ARITHMETICOP",
  "PLUS",
  "MINUS",
  "ORDEROP",
  "EQUALITYOP",
  "BOOLEANOP",
  "ASSIGNOP",
  "SEMICOLON",
  "PROGRAM",
  "BEGINBLK",
  "ENDBLK",
  "WITH",
  "DO",
  "REPEAT",
  "TIMES",
  "READ",
  "WRITE",
  "WRITELN",
  "IF",
  "THEN",
  "ELSE",
  "WHILE",
  "FOR",
  "FROM",
  "TO",
  "BY",
  "FUNC",
  "RETURN",
  "RETURNTYPE",
  "TYPE",
  "BOOLEAN",
  "LPARENTH",
  "RPARENTH",
  "SEP",
  "COLON",
  "NUMBER",
  "STRING",
  "IDENTIFIER",
  "PROGRAMBLOCK",
  "DEF",
  "\"                PROGRAMBLOCK        : PROGRAM INSTR ENDBLK SEP        ;        DEF        : FUNC IDENT LPARENTH PARAMLIST RPARENTH BEGINBLK FUNCINSTR ENDBLK SEP        | FUNC IDENT LPARENTH PARAMLIST RPARENTH RETURNTYPE TYPE BEGINBLK FUNCINSTR ENDBLK SEP        | FUNC IDENT LPARENTH RPARENTH BEGINBLK FUNCINSTR ENDBLK SEP        | FUNC IDENT LPARENTH RPARENTH BEGINBLK RETURNTYPE TYPE FUNCINSTR ENDBLK SEP        ;                IDENT        : IDENTIFIER        ;        PARAMLIST        : PARAM COLON PARAMLIST        | PARAM        ;                FUNCINSTR        : INSTR FUNCINSTR        | FUNCCOND SEP FUNCINSTR        | FUNCITER SEP FUNCINSTR        | FUNCWITHBLOCK SEP FUNCINSTR         | RETURNEXPR SEP FUNCINSTR        |         ;                PARAM        : TYPE IDENT        ;                INSTR        : EXPR SEP INSTR         | ASSIGN SEP INSTR        | COND SEP INSTR        | ITER SEP INSTR        | READBLOCK SEP INSTR        | WRITEBLOCK SEP INSTR        | WITHBLOCK SEP INSTR        |         ;                FUNCCOND        : IF BEXPR THEN FUNCINSTR ENDBLK        | IF BEXPR THEN FUNCINSTR ELSE FUNCINSTR ENDBLK        ;                FUNCITER        : WHILE BEXPR DO FUNCINSTR ENDBLK         | FOR IDENT FROM AEXPR TO AEXPR BY AEXPR DO FUNCINSTR ENDBLK        | FOR IDENT FROM AEXPR TO AEXPR DO FUNCINSTR ENDBLK        | REPEAT AEXPR TIMES FUNCINSTR ENDBLK        ;                FUNCWITHBLOCK        : WITH DECLBLOCK SEP DO FUNCINSTR ENDBLK        ;                RETURNEXPR         : RETURN        | RETURN EXPR        ;                EXPR        : AEXPR        | BEXPR        ;                ASSIGN        : IDENT ASSIGNOP EXPR        ;                COND        : IF BEXPR THEN INSTR ENDBLK        | IF BEXPR THEN INSTR ELSE INSTR ENDBLK        ;                ITER        : WHILE BEXPR DO INSTR ENDBLK         | FOR IDENT FROM AEXPR TO AEXPR BY AEXPR DO INSTR ENDBLK        | FOR IDENT FROM AEXPR TO AEXPR DO INSTR ENDBLK        | REPEAT AEXPR TIMES INSTR ENDBLK        ;                READBLOCK        : READ IDENT        ;                WRITEBLOCK        : WRITE PRINTLIST        | WRITELN PRINTLIST        ;                WITHBLOCK        : WITH DECLBLOCK SEP DO INSTR ENDBLK        ;                BEXPR        : BEXPR BOOLEANOP BEXPR        | LPARENTH BEXPR RPARENTH  = BPRNTS        | NOT BEXPR        | EXPR EQUALITYOP EXPR        | AEXPR ORDEROP AEXPR        | B        | IDENT        | CALLFUNC        ;                AEXPR        : AEXPR ARITHMETICOP AEXPR        | AEXPR MINUS AEXPR        | LPARENTH AEXPR RPARENTH  = APRNTS        | MINUS AEXPR   =UMINUS        | N        | IDENT        | CALLFUNC        ;                DECLBLOCK        : DECL DECLBLOCK        |        ;                PRINTLIST        : STRING COLON PRINTLIST        | EXPR COLON PRINTLIST        | STRING        | EXPR        ;                B        : BOOLEAN        ;                N        : NUMBER        ;                CALLFUNC        : IDENT LPARENTH TERMINALLIST RPARENTH        | IDENT LPARENTH RPARENTH        ;                DECL        : TYPE IDENTLIST SEP        | TYPE ASSIGN SEP        ;                TERMINALLIST        : B COLON TERMINALLIST        | N COLON TERMINALLIST        | IDENT COLON TERMINALLIST        | B        | N        | IDENT        ;                IDENTLIST        : IDENT COLON IDENTLIST        | IDENT        ;                        \"",
  "$start",
  "RETINA",
  "DEFBLOCK",
  "\"\"" ]

Racc_debug_parser = false

##### State transition tables end #####

# reduce 0 omitted

# reduce 1 omitted

# reduce 2 omitted

# reduce 3 omitted

# reduce 4 omitted

# reduce 5 omitted

def _reduce_none(val, _values, result)
  val[0]
end

end   # class Parser
